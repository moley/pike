

0. Vergleich mit Puppet / Chef

Puppet:                                                 Pike                                                Chef                                                CFEngine
- max. 50-100 Clients                                                                                                                                           - ca. 4000-5000 Clients
- Explizite Abhängigkeiten zwischen Aufgaben            -                                                   - Abhäng. durch Reihenfolge vorgegeben
- unterstützt viele  Plattformen                        - jede Plattform, auf der die JVM läuft             - wenige Plattformen
- durch eigene DSL einfach zu erlernen, aber starr      - einfache DSL, aber durch Groovy erweiterbar       - pure Ruby: schwer zu erlernen, aber flexibel
- Ruby                                                  - Groovy                                            - Ruby
- zentraler Server verwaltet die Konfigurationen        - Server verteilt die Konfigurationen
- Zurückspielen auf einen Stand vor dem Update möglich
- Installation Master+Client auf jedem Host             - einmalige Installation auf Master, Autoinstall
- Dateien nahe bei Konfiguration oder zentral (Repo)
- Module                                                - Verzeichnisse/Dateien
- Klasse                                                - Environment
- Types                                                 - Tasks
- Updatereihenfolge muss beachtet werden                - automatisch Server->Clients
- VCS: Jain                                             - VCS: Projektbeschreibungen im VCS möglich
- noch keine offizielle Windowsunterstützung
- schlechte Doku
- keine hierarchischen Hosts
- Infrastruktur groß, overengineered




1. Erzeugung von Gradletasks aufgrund des Modells
Im Modell kann man Hosts definieren und pro Host sowohl das Operatingsystem, das man vorher definiert haben
muss, refererenzieren. Zudem können pro Host eine beliebige Anzahl von Environments referenziert werden .
Jedes Environment kann dabei nochmals eine beliebige Anzahl von Tasks definieren. Diese Tasks werden
aus dem Modell abgeleitet und als Abhängigkeit in den Hauptinstallationstasks "install", "deinstall" und "check"
eingetragen.

2. Auflösung von Variablen.
Im Modell können zwei verschiedene Arten von Variablen verwendet werden:

 a) modellbezogene Variablen
  Möchte man andere Elemente des Modells referenzieren, so kann dies durch groovyeigene Variablen (z.B. ermittelt "${operatingsystem.programdir}
  das programdir des aktuellen operatingsystems)

   z.B.
 project.environments {
     buildnode {
         downloadVsaGradle {
             from = "http://hudson.intra.vsa.de:8080/view/gradle/job/createVsaGradle/lastSuccessfulBuild/artifact/build/vsagradle-1.5-all.zip"
             to = "${operatingsystem.programdir}"
         }
     }
 }

 b) von Pike mitgelieferte Variablen:
     '${user)'          ermittelt den aktuellen Benutzer
     '${currentPath}    ermittelt den aktuellen Pfad (z.B. für Tests)

3. Einfache Installation /

Ein Pike Projekt enthält die Definition der Installationsanweiseungen in der Datei configureHost.gradle.
Durch Aufruf des Installationstasks gradle autoinstall wird das komplette Pike auf denjenigen Hosts, die in der Installationsanweisung
definiert sind, installiert.

Autoinstallation, Vorraussetzung: auf Gegenseite muss
in /etc/ssh/sshd_conf der Eintrag "PasswordAuthentication yes" eingetragen 
sein und der ssh daemon muss laufen. Die Firewall sollte so konfiguriert sein, daß ssh-connections zugelassen werden

5. Einfaches Starten
Durch den Aufruf gradle configureRemotes -Pgroup=prod startet
auf allen Hosts, die der Gruppe prod angehören, Pike und versucht die Skripte einzuspielen


6. Simple Plan
Ein Simple Plan bundelt eine Reihe von Tasks und definiert eine fachliche Anforderung, z.B. das Einspielen eines JDKs auf dem Host.
Dies besteht z.B. aus den verschiedenen Tasks Downloaden des JDK, Setzen der JAVA_HOME, ....
Definiert wird ein Plan beispielsweise folgendermassen:

project.plans {
    jdks {                             <-  Planname
        matrix ('1.7.0_07', '1.6.0_something')

        downloadJdk {
            from = "http://hudson.intra.vsa.de:8080/userContent/tools/jdk${matrix}.zip"
            to = "${operatingsystem.programdir}"
            executable ("jdk${param}/bin/java")
            executable ("jdk${param}/jre/bin/java")
        }
        userenvJdk {
            exportedpath ("JDK17_HOME", "${operatingsystem.programdir}/jdk${matrix}", true)
        }

    }
}

Gradle sucht für die verschiedenen Taskdefinitionen eine passende Taskklasse.
Der Name des tasks bis zum ersten Großbuchstaben definiert dabei den zu suchenden Klassennamen.
Beispielsweise wird bei Angabe von downloadJdk ein Task DownloadTask im Verzeichnis org.pike.tasks gesucht, welcher
in diesem Fall konfiguriert und benutzt wird.


7. Matrix-Plan
Ein Matrix-Plan geht noch einen Schritt weiter. Für Aufgaben die pro Host mehrfach ausgeführt werden und
ähnliche Rahmenbedingungen definieren (z.B. Installiere auf einem Host ein jdk5, jdk6 und ein jdk7 jeweils in
ein gemeinsames Hauptverzeichnis) wird ein Plan definiert, der durch
matrix (....) die verschiedenen Ausprägungen konfiguriert bekommt. Innerhalb der Closures der einzelnen Task
kann man wiederum auf diese matrix-werte zugreifen und somit die Tasks dynamisch konfigurieren
Beispiel:
project.plans {
    jdks {                                              <- Planname
        matrix ('1.7.0_07', '1.6.0_something')          <- Ausprägungen der Plans

        downloadJdk {                                   <- in jedem Plan enthaltener Task
            from = "http://hudson.intra.vsa.de:8080/userContent/tools/jdk${matrix}.zip"
            to = "${operatingsystem.programdir}"
            executable ("jdk${param}/bin/java")
            executable ("jdk${param}/jre/bin/java")
        }
        userenvJdk {                                    <- in jedem Plan enthaltener Task
            exportedpath ("JDK17_HOME", "${operatingsystem.programdir}/jdk${matrix}", true)
        }

    }
}

Dies führt dazu, das für jede Matrixausprägung (1.7.0_07 und 1.6.0_something) Tasks erstellt werden und bei Aufruf von
install mit ausgeführt werden.




1 File downloaden
starten
fertig


8. Testen gegen VirtualBox VM

VBox + Image einrichten
- Installation Virtualbox

- VBox-Image downloaden (root:reverse)
- IgnoreRHosts = yes
-
- Firewall deaktivieren

- VBoxManage setproperty websrvauthlibrary null
- vboxwebsrv starten






